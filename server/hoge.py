{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import json\n",
    "from collections import defaultdict\n",
    "import numpy as np\n",
    "import math\n",
    "from tqdm.notebook import tqdm_notebook as tqdm\n",
    "import matplotlib.patches as pat\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {
    "tags": []
   },
   "outputs": [
    {
     "ename": "NameError",
     "evalue": "name 'concepts' is not defined",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mNameError\u001b[0m                                 Traceback (most recent call last)",
      "\u001b[0;32m<ipython-input-2-98767e6a623d>\u001b[0m in \u001b[0;36m<module>\u001b[0;34m\u001b[0m\n\u001b[1;32m      1\u001b[0m \u001b[0mcounter\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mdefaultdict\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;32mlambda\u001b[0m \u001b[0;34m:\u001b[0m\u001b[0;36m0\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      2\u001b[0m \u001b[0mappear\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mdefaultdict\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;32mlambda\u001b[0m \u001b[0;34m:\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m----> 3\u001b[0;31m \u001b[0;32mfor\u001b[0m \u001b[0mresource\u001b[0m \u001b[0;32min\u001b[0m \u001b[0mconcepts\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;34m'resources'\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;36m1\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m      4\u001b[0m     \u001b[0mr_name\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mresource\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;34m'name'\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      5\u001b[0m     \u001b[0;32mfor\u001b[0m \u001b[0md\u001b[0m \u001b[0;32min\u001b[0m \u001b[0mresource\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;34m'schema'\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;34m'fields'\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;31mNameError\u001b[0m: name 'concepts' is not defined"
     ]
    }
   ],
   "source": [
    "counter = defaultdict(lambda :0)\n",
    "appear = defaultdict(lambda :[])\n",
    "for resource in concepts['resources'][1:]:\n",
    "    r_name = resource['name']\n",
    "    for d in resource['schema']['fields']:\n",
    "        counter[d['name']] += 1\n",
    "        appear[d['name']].append(r_name)\n",
    "cnt2ind = defaultdict(lambda: [])\n",
    "for k, v in counter.items():\n",
    "    cnt2ind[v].append(k)\n",
    "for cnt in sorted(cnt2ind.keys()):\n",
    "    print(cnt, cnt2ind[cnt])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>name</th>\n",
       "      <th>region</th>\n",
       "      <th>income</th>\n",
       "      <th>population</th>\n",
       "      <th>lifeExpectancy</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>0</th>\n",
       "      <td>Angola</td>\n",
       "      <td>Sub-Saharan Africa</td>\n",
       "      <td>[[1800, 359.93], [1820, 359.93], [1913, 556.12...</td>\n",
       "      <td>[[1800, 1567028], [1820, 1567028], [1940, 3738...</td>\n",
       "      <td>[[1800, 26.98], [1940, 26.98], [1950, 29.22], ...</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1</th>\n",
       "      <td>Benin</td>\n",
       "      <td>Sub-Saharan Africa</td>\n",
       "      <td>[[1800, 553.72], [1820, 553.72], [1913, 855.53...</td>\n",
       "      <td>[[1800, 636559], [1820, 636559], [1950, 167266...</td>\n",
       "      <td>[[1800, 31], [1944, 31], [1950, 36.53], [1951,...</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>2</th>\n",
       "      <td>Botswana</td>\n",
       "      <td>Sub-Saharan Africa</td>\n",
       "      <td>[[1800, 407.36], [1820, 407.36], [1913, 629.4]...</td>\n",
       "      <td>[[1800, 121000], [1904, 121000], [1911, 125000...</td>\n",
       "      <td>[[1800, 33.6], [1945, 33.6], [1950, 46.82], [1...</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3</th>\n",
       "      <td>Burkina Faso</td>\n",
       "      <td>Sub-Saharan Africa</td>\n",
       "      <td>[[1800, 454.33], [1820, 454.33], [1913, 497.44...</td>\n",
       "      <td>[[1800, 1665421], [1820, 1665421], [1950, 4376...</td>\n",
       "      <td>[[1800, 29.2], [1945, 29.2], [1950, 32.89], [1...</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>4</th>\n",
       "      <td>Burundi</td>\n",
       "      <td>Sub-Saharan Africa</td>\n",
       "      <td>[[1800, 447.59], [1820, 447.59], [1913, 353.82...</td>\n",
       "      <td>[[1800, 899097], [1820, 899097], [1950, 236252...</td>\n",
       "      <td>[[1800, 31.5], [1945, 31.5], [1950, 38.42], [1...</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>...</th>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>175</th>\n",
       "      <td>Timor-Leste</td>\n",
       "      <td>East Asia &amp; Pacific</td>\n",
       "      <td>[[1800, 514.12], [1820, 518.73], [1850, 539.86...</td>\n",
       "      <td>[[1800, 137262], [1820, 137262], [1926, 442000...</td>\n",
       "      <td>[[1950, 28.97], [1951, 29.22], [1952, 29.73], ...</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>176</th>\n",
       "      <td>Tokelau</td>\n",
       "      <td>East Asia &amp; Pacific</td>\n",
       "      <td>[[2005, 889.43]]</td>\n",
       "      <td>[[1800, 1009], [1843, 1000], [1850, 1000], [19...</td>\n",
       "      <td>[[2006, 69]]</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>177</th>\n",
       "      <td>Tonga</td>\n",
       "      <td>East Asia &amp; Pacific</td>\n",
       "      <td>[[1800, 667.71], [1820, 667.71], [1913, 902.69...</td>\n",
       "      <td>[[1800, 18658], [1843, 18500], [1850, 18500], ...</td>\n",
       "      <td>[[1950, 57.91], [1951, 58.1], [1952, 58.47], [...</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>178</th>\n",
       "      <td>Vietnam</td>\n",
       "      <td>East Asia &amp; Pacific</td>\n",
       "      <td>[[1800, 459.71], [1820, 459.71], [1870, 440.8]...</td>\n",
       "      <td>[[1800, 6551000], [1820, 6551000], [1870, 1052...</td>\n",
       "      <td>[[1800, 32], [1930, 32], [1936, 33], [1950, 39...</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>179</th>\n",
       "      <td>Vanuatu</td>\n",
       "      <td>East Asia &amp; Pacific</td>\n",
       "      <td>[[1800, 829.58], [1820, 829.58], [1913, 1121.5...</td>\n",
       "      <td>[[1800, 27791], [1820, 27791], [1950, 52000], ...</td>\n",
       "      <td>[[1950, 40.8], [1951, 41.1], [1952, 41.7], [19...</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "<p>180 rows Ã— 5 columns</p>\n",
       "</div>"
      ],
      "text/plain": [
       "             name               region  \\\n",
       "0          Angola   Sub-Saharan Africa   \n",
       "1           Benin   Sub-Saharan Africa   \n",
       "2        Botswana   Sub-Saharan Africa   \n",
       "3    Burkina Faso   Sub-Saharan Africa   \n",
       "4         Burundi   Sub-Saharan Africa   \n",
       "..            ...                  ...   \n",
       "175   Timor-Leste  East Asia & Pacific   \n",
       "176       Tokelau  East Asia & Pacific   \n",
       "177         Tonga  East Asia & Pacific   \n",
       "178       Vietnam  East Asia & Pacific   \n",
       "179       Vanuatu  East Asia & Pacific   \n",
       "\n",
       "                                                income  \\\n",
       "0    [[1800, 359.93], [1820, 359.93], [1913, 556.12...   \n",
       "1    [[1800, 553.72], [1820, 553.72], [1913, 855.53...   \n",
       "2    [[1800, 407.36], [1820, 407.36], [1913, 629.4]...   \n",
       "3    [[1800, 454.33], [1820, 454.33], [1913, 497.44...   \n",
       "4    [[1800, 447.59], [1820, 447.59], [1913, 353.82...   \n",
       "..                                                 ...   \n",
       "175  [[1800, 514.12], [1820, 518.73], [1850, 539.86...   \n",
       "176                                   [[2005, 889.43]]   \n",
       "177  [[1800, 667.71], [1820, 667.71], [1913, 902.69...   \n",
       "178  [[1800, 459.71], [1820, 459.71], [1870, 440.8]...   \n",
       "179  [[1800, 829.58], [1820, 829.58], [1913, 1121.5...   \n",
       "\n",
       "                                            population  \\\n",
       "0    [[1800, 1567028], [1820, 1567028], [1940, 3738...   \n",
       "1    [[1800, 636559], [1820, 636559], [1950, 167266...   \n",
       "2    [[1800, 121000], [1904, 121000], [1911, 125000...   \n",
       "3    [[1800, 1665421], [1820, 1665421], [1950, 4376...   \n",
       "4    [[1800, 899097], [1820, 899097], [1950, 236252...   \n",
       "..                                                 ...   \n",
       "175  [[1800, 137262], [1820, 137262], [1926, 442000...   \n",
       "176  [[1800, 1009], [1843, 1000], [1850, 1000], [19...   \n",
       "177  [[1800, 18658], [1843, 18500], [1850, 18500], ...   \n",
       "178  [[1800, 6551000], [1820, 6551000], [1870, 1052...   \n",
       "179  [[1800, 27791], [1820, 27791], [1950, 52000], ...   \n",
       "\n",
       "                                        lifeExpectancy  \n",
       "0    [[1800, 26.98], [1940, 26.98], [1950, 29.22], ...  \n",
       "1    [[1800, 31], [1944, 31], [1950, 36.53], [1951,...  \n",
       "2    [[1800, 33.6], [1945, 33.6], [1950, 46.82], [1...  \n",
       "3    [[1800, 29.2], [1945, 29.2], [1950, 32.89], [1...  \n",
       "4    [[1800, 31.5], [1945, 31.5], [1950, 38.42], [1...  \n",
       "..                                                 ...  \n",
       "175  [[1950, 28.97], [1951, 29.22], [1952, 29.73], ...  \n",
       "176                                       [[2006, 69]]  \n",
       "177  [[1950, 57.91], [1951, 58.1], [1952, 58.47], [...  \n",
       "178  [[1800, 32], [1930, 32], [1936, 33], [1950, 39...  \n",
       "179  [[1950, 40.8], [1951, 41.1], [1952, 41.7], [19...  \n",
       "\n",
       "[180 rows x 5 columns]"
      ]
     },
     "execution_count": 3,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "nations = pd.read_json('../public/nations.json')\n",
    "nations"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "1b9ee381fb3b4e269ef62c1ead296908",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(HTML(value=''), FloatProgress(value=0.0, max=180.0), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n"
     ]
    },
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th></th>\n",
       "      <th></th>\n",
       "      <th>income</th>\n",
       "      <th>population</th>\n",
       "      <th>lifeExpectancy</th>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>name</th>\n",
       "      <th>year</th>\n",
       "      <th>region</th>\n",
       "      <th></th>\n",
       "      <th></th>\n",
       "      <th></th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th rowspan=\"5\" valign=\"top\">Angola</th>\n",
       "      <th>1800-01-01</th>\n",
       "      <th>Sub-Saharan Africa</th>\n",
       "      <td>359.93</td>\n",
       "      <td>1567028.0</td>\n",
       "      <td>26.98</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1801-01-01</th>\n",
       "      <th>Sub-Saharan Africa</th>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1802-01-01</th>\n",
       "      <th>Sub-Saharan Africa</th>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1803-01-01</th>\n",
       "      <th>Sub-Saharan Africa</th>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1804-01-01</th>\n",
       "      <th>Sub-Saharan Africa</th>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>...</th>\n",
       "      <th>...</th>\n",
       "      <th>...</th>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th rowspan=\"5\" valign=\"top\">Vanuatu</th>\n",
       "      <th>2005-01-01</th>\n",
       "      <th>East Asia &amp; Pacific</th>\n",
       "      <td>3477.00</td>\n",
       "      <td>205754.0</td>\n",
       "      <td>69.26</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>2006-01-01</th>\n",
       "      <th>East Asia &amp; Pacific</th>\n",
       "      <td>3632.57</td>\n",
       "      <td>208869.0</td>\n",
       "      <td>69.58</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>2007-01-01</th>\n",
       "      <th>East Asia &amp; Pacific</th>\n",
       "      <td>3779.08</td>\n",
       "      <td>211971.0</td>\n",
       "      <td>69.89</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>2008-01-01</th>\n",
       "      <th>East Asia &amp; Pacific</th>\n",
       "      <td>3916.57</td>\n",
       "      <td>215053.0</td>\n",
       "      <td>70.20</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>2009-01-01</th>\n",
       "      <th>East Asia &amp; Pacific</th>\n",
       "      <td>3943.30</td>\n",
       "      <td>NaN</td>\n",
       "      <td>70.50</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "<p>37800 rows Ã— 3 columns</p>\n",
       "</div>"
      ],
      "text/plain": [
       "                                         income  population  lifeExpectancy\n",
       "name    year       region                                                  \n",
       "Angola  1800-01-01 Sub-Saharan Africa    359.93   1567028.0           26.98\n",
       "        1801-01-01 Sub-Saharan Africa       NaN         NaN             NaN\n",
       "        1802-01-01 Sub-Saharan Africa       NaN         NaN             NaN\n",
       "        1803-01-01 Sub-Saharan Africa       NaN         NaN             NaN\n",
       "        1804-01-01 Sub-Saharan Africa       NaN         NaN             NaN\n",
       "...                                         ...         ...             ...\n",
       "Vanuatu 2005-01-01 East Asia & Pacific  3477.00    205754.0           69.26\n",
       "        2006-01-01 East Asia & Pacific  3632.57    208869.0           69.58\n",
       "        2007-01-01 East Asia & Pacific  3779.08    211971.0           69.89\n",
       "        2008-01-01 East Asia & Pacific  3916.57    215053.0           70.20\n",
       "        2009-01-01 East Asia & Pacific  3943.30         NaN           70.50\n",
       "\n",
       "[37800 rows x 3 columns]"
      ]
     },
     "execution_count": 4,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "inds = 'name year region income population lifeExpectancy'.split()\n",
    "new_nations = pd.DataFrame({k: [] for k in inds}, index=[])\n",
    "for nation in tqdm(nations.iterrows(), total=len(nations)):\n",
    "    d = defaultdict(lambda: {k: None for k in inds[3:]})\n",
    "    for k in inds[3:]:\n",
    "        for year, v in nation[1][k]:\n",
    "            d[year][k] = v\n",
    "    for year in range(1800, 2010):\n",
    "        d_tmp = dict(name=nation[1]['name'], year=year, region=nation[1]['region'])\n",
    "        d_tmp.update(d[year])\n",
    "        new_nations = new_nations.append(d_tmp, ignore_index=True)\n",
    "new_nations = new_nations.astype({'name': str, 'year': int, 'region': str, 'income': float, 'population': float, 'lifeExpectancy': float})\n",
    "new_nations['year'] = pd.to_datetime(new_nations['year'], format='%Y')\n",
    "new_nations_ = new_nations.set_index(['name', 'year'])\n",
    "new_nations__ = new_nations.set_index(['name', 'year', 'region'])\n",
    "new_nations__"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>name</th>\n",
       "      <th>region</th>\n",
       "      <th>income</th>\n",
       "      <th>population</th>\n",
       "      <th>lifeExpectancy</th>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>year</th>\n",
       "      <th></th>\n",
       "      <th></th>\n",
       "      <th></th>\n",
       "      <th></th>\n",
       "      <th></th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>1800-01-01</th>\n",
       "      <td>Angola</td>\n",
       "      <td>Sub-Saharan Africa</td>\n",
       "      <td>359.93</td>\n",
       "      <td>1567028.0</td>\n",
       "      <td>26.98</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1801-01-01</th>\n",
       "      <td>Angola</td>\n",
       "      <td>Sub-Saharan Africa</td>\n",
       "      <td>359.93</td>\n",
       "      <td>1567028.0</td>\n",
       "      <td>26.98</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1802-01-01</th>\n",
       "      <td>Angola</td>\n",
       "      <td>Sub-Saharan Africa</td>\n",
       "      <td>359.93</td>\n",
       "      <td>1567028.0</td>\n",
       "      <td>26.98</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1803-01-01</th>\n",
       "      <td>Angola</td>\n",
       "      <td>Sub-Saharan Africa</td>\n",
       "      <td>359.93</td>\n",
       "      <td>1567028.0</td>\n",
       "      <td>26.98</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1804-01-01</th>\n",
       "      <td>Angola</td>\n",
       "      <td>Sub-Saharan Africa</td>\n",
       "      <td>359.93</td>\n",
       "      <td>1567028.0</td>\n",
       "      <td>26.98</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>...</th>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>2005-01-01</th>\n",
       "      <td>Angola</td>\n",
       "      <td>Sub-Saharan Africa</td>\n",
       "      <td>3533.00</td>\n",
       "      <td>11827315.0</td>\n",
       "      <td>45.52</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>2006-01-01</th>\n",
       "      <td>Angola</td>\n",
       "      <td>Sub-Saharan Africa</td>\n",
       "      <td>4069.56</td>\n",
       "      <td>12127071.0</td>\n",
       "      <td>46.02</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>2007-01-01</th>\n",
       "      <td>Angola</td>\n",
       "      <td>Sub-Saharan Africa</td>\n",
       "      <td>4755.46</td>\n",
       "      <td>12420476.0</td>\n",
       "      <td>46.54</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>2008-01-01</th>\n",
       "      <td>Angola</td>\n",
       "      <td>Sub-Saharan Africa</td>\n",
       "      <td>5228.74</td>\n",
       "      <td>12707546.0</td>\n",
       "      <td>47.06</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>2009-01-01</th>\n",
       "      <td>Angola</td>\n",
       "      <td>Sub-Saharan Africa</td>\n",
       "      <td>5055.59</td>\n",
       "      <td>12707546.0</td>\n",
       "      <td>47.58</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "<p>210 rows Ã— 5 columns</p>\n",
       "</div>"
      ],
      "text/plain": [
       "              name              region   income  population  lifeExpectancy\n",
       "year                                                                       \n",
       "1800-01-01  Angola  Sub-Saharan Africa   359.93   1567028.0           26.98\n",
       "1801-01-01  Angola  Sub-Saharan Africa   359.93   1567028.0           26.98\n",
       "1802-01-01  Angola  Sub-Saharan Africa   359.93   1567028.0           26.98\n",
       "1803-01-01  Angola  Sub-Saharan Africa   359.93   1567028.0           26.98\n",
       "1804-01-01  Angola  Sub-Saharan Africa   359.93   1567028.0           26.98\n",
       "...            ...                 ...      ...         ...             ...\n",
       "2005-01-01  Angola  Sub-Saharan Africa  3533.00  11827315.0           45.52\n",
       "2006-01-01  Angola  Sub-Saharan Africa  4069.56  12127071.0           46.02\n",
       "2007-01-01  Angola  Sub-Saharan Africa  4755.46  12420476.0           46.54\n",
       "2008-01-01  Angola  Sub-Saharan Africa  5228.74  12707546.0           47.06\n",
       "2009-01-01  Angola  Sub-Saharan Africa  5055.59  12707546.0           47.58\n",
       "\n",
       "[210 rows x 5 columns]"
      ]
     },
     "execution_count": 5,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "new_nations.groupby('name').get_group('Angola').sort_values('year').set_index('year').interpolate('time')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "<matplotlib.axes._subplots.AxesSubplot at 0x7fee4a5feb90>"
      ]
     },
     "execution_count": 25,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "g = new_nations.groupby('name')\n",
    "for k in g.groups.keys():\n",
    "    df = g.get_group(k).sort_values('year').set_index('year').interpolate('time')\n",
    "    break\n",
    "sns.lineplot(x=range(1800, 2010), y='income', data=df)\n",
    "p = peaks(df['income'], 5)\n",
    "for x in np.argsort(p)[::-1][:5]:\n",
    "    x += 1800\n",
    "    plt.plot([x, x], [0, 1200])\n",
    "sns.lineplot(range(1800, 2010), p)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 82,
   "metadata": {},
   "outputs": [],
   "source": [
    "def c(ys):\n",
    "    y_mean = np.mean(ys)\n",
    "    return np.sum(np.abs(ys-y_mean))\n",
    "\n",
    "def d(ys1, ys2):\n",
    "    return c(pd.concat([ys1, ys2])) - c(ys1) - c(ys2)\n",
    "\n",
    "\n",
    "# salient peaks\n",
    "def A(ys, window_size, K=5):\n",
    "    peaks = []\n",
    "    for i in range(1, len(ys)-1):\n",
    "        if max(ys[i-1], ys[i+1]) < ys[i]:\n",
    "            peaks.append((int(max(0, i-window_size//2)), int(min(len(ys), i+window_size//2)), 'peak', d(ys[max(0, i-window_size//2):i], ys[i:i+window_size//2])))\n",
    "        elif min(ys[i-1], ys[i+1]) > ys[i]:\n",
    "            peaks.append((int(max(0, i-window_size//2)), int(min(len(ys), i+window_size//2)), 'valley', d(ys[max(0, i-window_size//2):i], ys[i:i+window_size//2])))\n",
    "        else:\n",
    "            pass\n",
    "    peaks = sorted(peaks, key=lambda x: x[3])[::-1][:K]\n",
    "    peaks = sorted(peaks, key=lambda x: x[0])\n",
    "    ret = []\n",
    "    pre_from_, pre_to_, p_type_pre, v = peaks[0]\n",
    "    if v == 0:\n",
    "        return ret\n",
    "    for from_, to_, p_type, v in peaks[1:]:\n",
    "        if v == 0:\n",
    "            ret.append((pre_from_, pre_to_, p_type_pre))\n",
    "            break\n",
    "        if pre_to_ >= from_:\n",
    "            pre_to_ = to_\n",
    "            if p_type_pre != p_type:\n",
    "                p_type_pre = 'vibration'\n",
    "        else:\n",
    "            ret.append((pre_from_, pre_to_, p_type_pre))\n",
    "            pre_from_, pre_to_, p_type_pre = from_, to_, p_type\n",
    "    ret.append((pre_from_, pre_to_, p_type_pre))\n",
    "    return ret\n",
    "\n",
    "\n",
    "        \n",
    "def get_grad(ys):\n",
    "    if len(ys)==0:\n",
    "        return 0\n",
    "    ys = np.array(ys).reshape(-1)\n",
    "    a, b = np.linalg.lstsq(np.array([[i, 1] for i in range(len(ys))]), ys)[0]\n",
    "    return a\n",
    "\n",
    "\n",
    "# trend changes\n",
    "def B(ys, window_size, k_sigma=3):\n",
    "    grad_diff = []\n",
    "    for i in range(len(ys)):\n",
    "        grad_former = get_grad(ys[max(0, i-window_size//2):i])\n",
    "        grad_latter = get_grad(ys[i:i+window_size//2])\n",
    "        grad_diff.append(grad_former-grad_latter)\n",
    "    x = np.array(grad_diff)\n",
    "    xmean = x.mean(axis=0)\n",
    "    xstd  = np.std(x, axis=0)\n",
    "    change_points = []\n",
    "    for i in range(len(x)):\n",
    "        if x[i] < xmean-k_sigma*xstd:\n",
    "            change_points.append((int(max(0, i-window_size//2)), int(min(len(ys), i+window_size//2)), 'trend_increase'))\n",
    "        elif xmean+k_sigma*xstd < x[i]:\n",
    "            change_points.append((int(max(0, i-window_size//2)), int(min(len(ys), i+window_size//2)), 'trend_decrease'))\n",
    "\n",
    "    ret = []\n",
    "    if len(change_points)==0:\n",
    "        return ret\n",
    "\n",
    "    pre_from_, pre_to_, p_type_pre = change_points[0]\n",
    "    for from_, to_, p_type in change_points[1:]:\n",
    "        if pre_to_ >= from_:\n",
    "            pre_to_ = to_\n",
    "            if p_type_pre != p_type:\n",
    "                p_type_pre = 'trend_confusion'\n",
    "        else:\n",
    "            ret.append((pre_from_, pre_to_, p_type_pre))\n",
    "            pre_from_, pre_to_, p_type_pre = from_, to_, p_type\n",
    "    ret.append((pre_from_, pre_to_, p_type_pre))\n",
    "    return ret\n",
    "\n",
    "\n",
    "def large_grad(ys, window_size, k_sigma=3):\n",
    "    grads = [get_grad(ys[max(0, i-window_size//2):i+window_size//2]) for i in range(len(ys))]\n",
    "    x = np.array(grads)\n",
    "    xmean = x.mean(axis=0)\n",
    "    xstd  = np.std(x, axis=0)\n",
    "    large_grad_points = []\n",
    "    for i in range(len(x)):\n",
    "        if x[i] < xmean-k_sigma*xstd:\n",
    "            large_grad_points.append((int(max(0, i-window_size//2)), int(min(len(ys), i+window_size//2)), 'neg_grad'))\n",
    "        elif xmean+k_sigma*xstd < x[i]:\n",
    "            large_grad_points.append((int(max(0, i-window_size//2)), int(min(len(ys), i+window_size//2)), 'pos_grad'))\n",
    "    ret = []\n",
    "    if len(large_grad_points)==0:\n",
    "        return ret\n",
    "\n",
    "    pre_from_, pre_to_, p_type_pre = large_grad_points[0]\n",
    "    for from_, to_, p_type in large_grad_points[1:]:\n",
    "        if pre_to_ >= from_ and p_type_pre == p_type:\n",
    "            pre_to_ = to_\n",
    "        else:\n",
    "            ret.append((pre_from_, pre_to_, p_type_pre))\n",
    "            pre_from_, pre_to_, p_type_pre = from_, to_, p_type\n",
    "    ret.append((pre_from_, pre_to_, p_type_pre))\n",
    "    return ret\n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 78,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 720x360 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/Users/hirotanaka/.pyenv/versions/miniconda3-4.3.30/envs/tdb/lib/python3.7/site-packages/ipykernel_launcher.py:45: FutureWarning: `rcond` parameter will change to the default of machine precision times ``max(M, N)`` where M and N are the input matrix dimensions.\n",
      "To use the future default and silence this warning we advise to pass `rcond=None`, to keep using the old, explicitly pass `rcond=-1`.\n"
     ]
    },
    {
     "data": {
      "image/png": "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iIiIiPhILJWhLGCUBgofJhW+ByIiIiI+Ek9lKC8t/LAnKFATEREROUo8laHcB/PTQIGaiIiIyFHiqawv9lADBWoiIiIiR4klM76oSgAK1ERERESOEk9nfLGHGihQExERETmKFhOIiIiI+FQsldViAhERERE/SqQyvtjsFhSoiYiIiBwllsr4onwUKFATEREROYrmqImIiEjR2xUZ5p5nX8I5V+iuzKlYUhk1ERERKXKP9e7jwVe6SGWzhe7KnIqns4S04a2IiIgUs0gsDkAinSlwT+ZOJutIprPa8FZERESK20Sgllk8gVo+6NSGtyIiIlLUBr1ALb6IMmovHxgFUEZNREREipdzjqFYAoDkIsmobemOcOtdW1heV871a5cWujuAAjURERE5gS//fCf/8B87j2sfTaYmFhEshozakz0RPnzXZpprQ/zrJ17DivqKQncJmMdAzczuNrNDZvb8pLawmT1sZju96wav3czsK2a2y8y2m9nlk55zq3f8TjO7db76KyIiIkdzznHvE7v5h1/sYiSWOuqx/Pw0WBxz1H7y3AEAvvt7V7HSJ0EazG9G7evADce03QE84pxbAzzi3Qe4EVjjXTYCX4VcYAd8DugE1gOfywd3IiIiMr/2DscYHE8ST2V54Jm9Rz02ODlQS6cXumtzbiiaoqk6RGN1qNBdOcq8BWrOuV8BkWOabwbu8W7fA7xjUvu9LmcTUG9my4G3AA875yLOuSHgYY4P/kRERGQePNs7AkBdRRn3bek9amPbwUWWURuJJamrKCt0N46z0HPUljrn9gN410u89pVA76Tj+ry26dpFRERknm3vGyYYKOFT163hpf2H6RkdmXjsqKHPRTBHbTiaoqFKgdp0bIo2d4L241/AbKOZbTOzbf39/XPaORERkTPRs33DnL+8hvesW0VFWYDH9u+ZeCwSixMM5MKIxZBRG4omqa8IFrobx1noQO2gN6SJd33Ia+8DWiYdtwrYd4L24zjn7nTOrXPOrWtubp7zjouIiJxJMlnHc30jXNJST215GTddvJyth/YR8+ajRWJxlldXAYsjozYSS1FXqYzag0B+5eatwAOT2j/irf7cAIx4Q6M/A95sZg3eIoI3e20iIiIyj7r6xxhPZrh4VT0Ab79kBYlMhpcHhoDcHLUlVZUEzIo+o+acyw19nkmBmpndBzwBnGtmfWb2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uSbEp960hi1/ch2P3/FG7rltPQb86Q+fw7kjK0Rf7R/jk996Cofjb376Mv/7112n1M8HntnLkpoQnR2NNNXkAq+TZdTye6g1neKqT4C6ULCoMmp1wUUUqAF/C7zZOfd659w1wFuA/zl/3RIRESmsZDrLT57bP7HdxqauCABXnTW7QC2vpMRYWV/B689p5v+78Twe3zXID57ObaExEk3xu/dsIxgo4Wd/eA03XbScv/zxS/z9IztJzWDFZt54KsWjO/r5rUtWECgxqoIBystKTppRO1KQ/TQCtfIQw0WQUYvE4lQHywgG/F88HmY+R63MObcjf8c594qZlc1Tn0RERAru29t6+S8/fJ4v33IpN1+6kie6BqgKBuakkPcH17fyw6f38oV/e5Et3REeem4/sVSGb318A6sbq/i7Wy6lpMT424df4YFn9/G25RfQ3Nx00td9ZmA/yUyWmy9dAeQWODTXhE66l1q+zueprvoEqC8P8crg0Ck/f6FEYgnCFcWRTYOZZ9S2mdldZnatd/kXcpveioiILEoPeNmuf/l1F8653Py09vBpTfTPKykx/vqdFzGeyPCjZ/fxpvOXcv/GDVzZliv6UxYo4Su3XMq/fGQdyXSWLz+7mQNjJ9/qY8vBfbQ1Vh4VTDZVhxZs6HM0kSTj/LHh73QisTiNRRSozTSj9gngduAPAAN+RW6umoiIyKLTG4myrWeI85bV8Pzew/xo+352HRrjvVesmrP3OHdZDY/+8bU0VAapCB4/DGdmXL92KY3VQd71T7+h7/Aoy6orp329SCzOK8OD/P51a44qwt5cHaJn8EiQl0xnCZQYgUl1LvNDn9OtRJ2JuvIQWWAskaSu3L97lA3G4rTV1xa6GzM20/8WlAJfds69yzn3TuArQHEM7oqIiMzSg8/uA+AfP3g5jVVB/uwHzwHMeiHByayor5gySJtsVUMFAP3R2AmP+03vfhzw9ktWHNXedMzQ501f+TV/+eMXjzpmcDxBXUXZaWUL60O54MzP89TS2Swj8URRZdRmekYeASom3a8Afj733RERESks5xw/fHovV7Y1cFZzNR+5qo3D8TQ1oVIuWLHwmZimqhClVsKh8RMHao/17qOlupazlxy9sW5zdYhINFdGKjKeZOehMb69tZfR+JFdtgZPo85nXl157vnDPl75ORxP4GBRzlErd86N5e94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\n",
      "text/plain": [
       "<Figure size 720x360 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/Users/hirotanaka/.pyenv/versions/miniconda3-4.3.30/envs/tdb/lib/python3.7/site-packages/ipykernel_launcher.py:45: FutureWarning: `rcond` parameter will change to the default of machine precision times ``max(M, N)`` where M and N are the input matrix dimensions.\n",
      "To use the future default and silence this warning we advise to pass `rcond=None`, to keep using the old, explicitly pass `rcond=-1`.\n"
     ]
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 720x360 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "\n",
    "ind = 'income'\n",
    "window_size_A = 6\n",
    "window_size_B = 4\n",
    "window_size_C = 4\n",
    "\n",
    "g = new_nations.groupby('name')\n",
    "for k in g.groups.keys():\n",
    "    df = g.get_group(k).sort_values('year').set_index('year').interpolate('time')\n",
    "    break\n",
    "ys = df[ind]\n",
    "\n",
    "\n",
    "fig = plt.figure(figsize=(10, 5))\n",
    "ax = fig.add_subplot(111)\n",
    "sns.lineplot(x=range(1800, 2010), y=ind, data=df)\n",
    "for from_, to_, ptype in A(ys, window_size_A):\n",
    "    from_ += 1800\n",
    "    to_ += 1800\n",
    "    ax.add_patch(pat.Rectangle(xy=(from_, 0), width=to_-from_, height=1200, color='red', alpha=0.2))\n",
    "    x = (from_+to_)/2\n",
    "    # plt.plot([x, x], [0, 1200])\n",
    "plt.show()\n",
    "\n",
    "\n",
    "fig = plt.figure(figsize=(10, 5))\n",
    "ax = fig.add_subplot(111)\n",
    "sns.lineplot(x=range(1800, 2010), y=ind, data=df)\n",
    "for from_, to_, ptype in B(ys, window_size_B, k_sigma=3):\n",
    "    from_ += 1800\n",
    "    to_ += 1800\n",
    "    ax.add_patch(pat.Rectangle(xy=(from_, 0), width=to_-from_, height=1200, color='blue', alpha=0.2))\n",
    "    x = (from_+to_)/2\n",
    "    # plt.plot([x, x], [0, 1200])\n",
    "plt.show()\n",
    "\n",
    "\n",
    "fig = plt.figure(figsize=(10, 5))\n",
    "ax = fig.add_subplot(111)\n",
    "sns.lineplot(x=range(1800, 2010), y=ind, data=df)\n",
    "for from_, to_, ptype in large_grad(ys, window_size_C, k_sigma=3):\n",
    "    from_ += 1800\n",
    "    to_ += 1800\n",
    "    ax.add_patch(pat.Rectangle(xy=(from_, 0), width=to_-from_, height=1200, facecolor='blue', edgecolor='red', alpha=0.2))\n",
    "    x = (from_+to_)/2\n",
    "    # plt.plot([x, x], [0, 1200])\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 69,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Help on class Rectangle in module matplotlib.patches:\n",
      "\n",
      "class Rectangle(Patch)\n",
      " |  Rectangle(xy, width, height, angle=0.0, **kwargs)\n",
      " |  \n",
      " |  A rectangle with lower left at *xy* = (*x*, *y*) with\n",
      " |  specified *width*, *height* and rotation *angle*.\n",
      " |  \n",
      " |  Method resolution order:\n",
      " |      Rectangle\n",
      " |      Patch\n",
      " |      matplotlib.artist.Artist\n",
      " |      builtins.object\n",
      " |  \n",
      " |  Methods defined here:\n",
      " |  \n",
      " |  __init__(self, xy, width, height, angle=0.0, **kwargs)\n",
      " |      Parameters\n",
      " |      ----------\n",
      " |      xy : (float, float)\n",
      " |          The bottom and left rectangle coordinates\n",
      " |      width : float\n",
      " |          Rectangle width\n",
      " |      height : float\n",
      " |          Rectangle height\n",
      " |      angle : float, optional\n",
      " |        rotation in degrees anti-clockwise about *xy* (default is 0.0)\n",
      " |      fill : bool, optional\n",
      " |          Whether to fill the rectangle (default is ``True``)\n",
      " |      \n",
      " |      Notes\n",
      " |      -----\n",
      " |      Valid kwargs are:\n",
      " |        agg_filter: a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array\n",
      " |        alpha: float or None\n",
      " |        animated: bool\n",
      " |        antialiased or aa: unknown\n",
      " |        capstyle: {'butt', 'round', 'projecting'}\n",
      " |        clip_box: `.Bbox`\n",
      " |        clip_on: bool\n",
      " |        clip_path: [(`~matplotlib.path.Path`, `.Transform`) | `.Patch` | None]\n",
      " |        color: color\n",
      " |        contains: callable\n",
      " |        edgecolor or ec: color or None or 'auto'\n",
      " |        facecolor or fc: color or None\n",
      " |        figure: `.Figure`\n",
      " |        fill: bool\n",
      " |        gid: str\n",
      " |        hatch: {'/', '\\\\', '|', '-', '+', 'x', 'o', 'O', '.', '*'}\n",
      " |        in_layout: bool\n",
      " |        joinstyle: {'miter', 'round', 'bevel'}\n",
      " |        label: object\n",
      " |        linestyle or ls: {'-', '--', '-.', ':', '', (offset, on-off-seq), ...}\n",
      " |        linewidth or lw: float or None\n",
      " |        path_effects: `.AbstractPathEffect`\n",
      " |        picker: None or bool or float or callable\n",
      " |        rasterized: bool or None\n",
      " |        sketch_params: (scale: float, length: float, randomness: float)\n",
      " |        snap: bool or None\n",
      " |        transform: `.Transform`\n",
      " |        url: str\n",
      " |        visible: bool\n",
      " |        zorder: float\n",
      " |  \n",
      " |  __str__(self)\n",
      " |      Return str(self).\n",
      " |  \n",
      " |  get_bbox(self)\n",
      " |  \n",
      " |  get_height(self)\n",
      " |      Return the height of the rectangle.\n",
      " |  \n",
      " |  get_patch_transform(self)\n",
      " |      Return the :class:`~matplotlib.transforms.Transform` instance which\n",
      " |      takes patch coordinates to data coordinates.\n",
      " |      \n",
      " |      For example, one may define a patch of a circle which represents a\n",
      " |      radius of 5 by providing coordinates for a unit circle, and a\n",
      " |      transform which scales the coordinates (the patch coordinate) by 5.\n",
      " |  \n",
      " |  get_path(self)\n",
      " |      Return the vertices of the rectangle.\n",
      " |  \n",
      " |  get_width(self)\n",
      " |      Return the width of the rectangle.\n",
      " |  \n",
      " |  get_x(self)\n",
      " |      Return the left coord of the rectangle.\n",
      " |  \n",
      " |  get_xy(self)\n",
      " |      Return the left and bottom coords of the rectangle.\n",
      " |  \n",
      " |  get_y(self)\n",
      " |      Return the bottom coord of the rectangle.\n",
      " |  \n",
      " |  set_bounds(self, *args)\n",
      " |      Set the bounds of the rectangle: l,b,w,h\n",
      " |      \n",
      " |      ACCEPTS: (left, bottom, width, height)\n",
      " |  \n",
      " |  set_height(self, h)\n",
      " |      Set the height of the rectangle.\n",
      " |  \n",
      " |  set_width(self, w)\n",
      " |      Set the width of the rectangle.\n",
      " |  \n",
      " |  set_x(self, x)\n",
      " |      Set the left coord of the rectangle.\n",
      " |  \n",
      " |  set_xy(self, xy)\n",
      " |      Set the left and bottom coords of the rectangle.\n",
      " |      \n",
      " |      Parameters\n",
      " |      ----------\n",
      " |      xy : (float, float)\n",
      " |  \n",
      " |  set_y(self, y)\n",
      " |      Set the bottom coord of the rectangle.\n",
      " |  \n",
      " |  ----------------------------------------------------------------------\n",
      " |  Data descriptors defined here:\n",
      " |  \n",
      " |  xy\n",
      " |      Return the left and bottom coords of the rectangle.\n",
      " |  \n",
      " |  ----------------------------------------------------------------------\n",
      " |  Methods inherited from Patch:\n",
      " |  \n",
      " |  contains(self, mouseevent, radius=None)\n",
      " |      Test whether the mouse event occurred in the patch.\n",
      " |      \n",
      " |      Returns\n",
      " |      -------\n",
      " |      (bool, empty dict)\n",
      " |  \n",
      " |  contains_point(self, point, radius=None)\n",
      " |      Returns ``True`` if the given *point* is inside the path\n",
      " |      (transformed with its transform attribute).\n",
      " |      \n",
      " |      *radius* allows the path to be made slightly larger or smaller.\n",
      " |  \n",
      " |  contains_points(self, points, radius=None)\n",
      " |      Returns a bool array which is ``True`` if the (closed) path\n",
      " |      contains the corresponding point.\n",
      " |      (transformed with its transform attribute).\n",
      " |      \n",
      " |      *points* must be Nx2 array.\n",
      " |      *radius* allows the path to be made slightly larger or smaller.\n",
      " |  \n",
      " |  draw(self, renderer)\n",
      " |      Draw the :class:`Patch` to the given *renderer*.\n",
      " |  \n",
      " |  get_aa(self)\n",
      " |      Alias for `get_antialiased`.\n",
      " |  \n",
      " |  get_antialiased(self)\n",
      " |      Returns True if the :class:`Patch` is to be drawn with antialiasing.\n",
      " |  \n",
      " |  get_capstyle(self)\n",
      " |      Return the current capstyle\n",
      " |  \n",
      " |  get_data_transform(self)\n",
      " |      Return the :class:`~matplotlib.transforms.Transform` instance which\n",
      " |      maps data coordinates to physical coordinates.\n",
      " |  \n",
      " |  get_ec(self)\n",
      " |      Alias for `get_edgecolor`.\n",
      " |  \n",
      " |  get_edgecolor(self)\n",
      " |      Return the edge color of the :class:`Patch`.\n",
      " |  \n",
      " |  get_extents(self)\n",
      " |      Return a :class:`~matplotlib.transforms.Bbox` object defining\n",
      " |      the axis-aligned extents of the :class:`Patch`.\n",
      " |  \n",
      " |  get_facecolor(self)\n",
      " |      Return the face color of the :class:`Patch`.\n",
      " |  \n",
      " |  get_fc(self)\n",
      " |      Alias for `get_facecolor`.\n",
      " |  \n",
      " |  get_fill(self)\n",
      " |      return whether fill is set\n",
      " |  \n",
      " |  get_hatch(self)\n",
      " |      Return the current hatching pattern\n",
      " |  \n",
      " |  get_joinstyle(self)\n",
      " |      Return the current joinstyle\n",
      " |  \n",
      " |  get_linestyle(self)\n",
      " |      Return the linestyle.\n",
      " |  \n",
      " |  get_linewidth(self)\n",
      " |      Return the line width in points.\n",
      " |  \n",
      " |  get_ls(self)\n",
      " |      Alias for `get_linestyle`.\n",
      " |  \n",
      " |  get_lw(self)\n",
      " |      Alias for `get_linewidth`.\n",
      " |  \n",
      " |  get_transform(self)\n",
      " |      Return the :class:`~matplotlib.transforms.Transform` applied\n",
      " |      to the :class:`Patch`.\n",
      " |  \n",
      " |  get_verts(self)\n",
      " |      Return a copy of the vertices used in this patch\n",
      " |      \n",
      " |      If the patch contains Bezier curves, the curves will be\n",
      " |      interpolated by line segments.  To access the curves as\n",
      " |      curves, use :meth:`get_path`.\n",
      " |  \n",
      " |  get_window_extent(self, renderer=None)\n",
      " |      Get the axes bounding box in display space.\n",
      " |      \n",
      " |      The bounding box' width and height are nonnegative.\n",
      " |      \n",
      " |      Subclasses should override for inclusion in the bounding box\n",
      " |      \"tight\" calculation. Default is to return an empty bounding\n",
      " |      box at 0, 0.\n",
      " |      \n",
      " |      Be careful when using this function, the results will not update\n",
      " |      if the artist window extent of the artist changes.  The extent\n",
      " |      can change due to any changes in the transform stack, such as\n",
      " |      changing the axes limits, the figure size, or the canvas used\n",
      " |      (as is done when saving a figure).  This can lead to unexpected\n",
      " |      behavior where interactive figures will look fine on the screen,\n",
      " |      but will save incorrectly.\n",
      " |  \n",
      " |  set_aa(self, aa)\n",
      " |      Alias for `set_antialiased`.\n",
      " |  \n",
      " |  set_alpha(self, alpha)\n",
      " |      Set the alpha transparency of the patch.\n",
      " |      \n",
      " |      Parameters\n",
      " |      ----------\n",
      " |      alpha : float or None\n",
      " |  \n",
      " |  set_antialiased(self, aa)\n",
      " |      Set whether to use antialiased rendering.\n",
      " |      \n",
      " |      Parameters\n",
      " |      ----------\n",
      " |      b : bool or None\n",
      " |  \n",
      " |  set_capstyle(self, s)\n",
      " |      Set the patch capstyle\n",
      " |      \n",
      " |      Parameters\n",
      " |      ----------\n",
      " |      s : {'butt', 'round', 'projecting'}\n",
      " |  \n",
      " |  set_color(self, c)\n",
      " |      Set both the edgecolor and the facecolor.\n",
      " |      \n",
      " |      Parameters\n",
      " |      ----------\n",
      " |      c : color\n",
      " |      \n",
      " |      See Also\n",
      " |      --------\n",
      " |      Patch.set_facecolor, Patch.set_edgecolor\n",
      " |          For setting the edge or face color individually.\n",
      " |  \n",
      " |  set_ec(self, color)\n",
      " |      Alias for `set_edgecolor`.\n",
      " |  \n",
      " |  set_edgecolor(self, color)\n",
      " |      Set the patch edge color.\n",
      " |      \n",
      " |      Parameters\n",
      " |      ----------\n",
      " |      color : color or None or 'auto'\n",
      " |  \n",
      " |  set_facecolor(self, color)\n",
      " |      Set the patch face color.\n",
      " |      \n",
      " |      Parameters\n",
      " |      ----------\n",
      " |      color : color or None\n",
      " |  \n",
      " |  set_fc(self, color)\n",
      " |      Alias for `set_facecolor`.\n",
      " |  \n",
      " |  set_fill(self, b)\n",
      " |      Set whether to fill the patch.\n",
      " |      \n",
      " |      Parameters\n",
      " |      ----------\n",
      " |      b : bool\n",
      " |  \n",
      " |  set_hatch(self, hatch)\n",
      " |      Set the hatching pattern\n",
      " |      \n",
      " |      *hatch* can be one of::\n",
      " |      \n",
      " |        /   - diagonal hatching\n",
      " |        \\   - back diagonal\n",
      " |        |   - vertical\n",
      " |        -   - horizontal\n",
      " |        +   - crossed\n",
      " |        x   - crossed diagonal\n",
      " |        o   - small circle\n",
      " |        O   - large circle\n",
      " |        .   - dots\n",
      " |        *   - stars\n",
      " |      \n",
      " |      Letters can be combined, in which case all the specified\n",
      " |      hatchings are done.  If same letter repeats, it increases the\n",
      " |      density of hatching of that pattern.\n",
      " |      \n",
      " |      Hatching is supported in the PostScript, PDF, SVG and Agg\n",
      " |      backends only.\n",
      " |      \n",
      " |      Parameters\n",
      " |      ----------\n",
      " |      hatch : {'/', '\\\\', '|', '-', '+', 'x', 'o', 'O', '.', '*'}\n",
      " |  \n",
      " |  set_joinstyle(self, s)\n",
      " |      Set the patch joinstyle\n",
      " |      \n",
      " |      Parameters\n",
      " |      ----------\n",
      " |      s : {'miter', 'round', 'bevel'}\n",
      " |  \n",
      " |  set_linestyle(self, ls)\n",
      " |      Set the patch linestyle.\n",
      " |      \n",
      " |      ===========================   =================\n",
      " |      linestyle                     description\n",
      " |      ===========================   =================\n",
      " |      ``'-'`` or ``'solid'``        solid line\n",
      " |      ``'--'`` or  ``'dashed'``     dashed line\n",
      " |      ``'-.'`` or  ``'dashdot'``    dash-dotted line\n",
      " |      ``':'`` or ``'dotted'``       dotted line\n",
      " |      ===========================   =================\n",
      " |      \n",
      " |      Alternatively a dash tuple of the following form can be provided::\n",
      " |      \n",
      " |          (offset, onoffseq),\n",
      " |      \n",
      " |      where ``onoffseq`` is an even length tuple of on and off ink in points.\n",
      " |      \n",
      " |      Parameters\n",
      " |      ----------\n",
      " |      ls : {'-', '--', '-.', ':', '', (offset, on-off-seq), ...}\n",
      " |          The line style.\n",
      " |  \n",
      " |  set_linewidth(self, w)\n",
      " |      Set the patch linewidth in points.\n",
      " |      \n",
      " |      Parameters\n",
      " |      ----------\n",
      " |      w : float or None\n",
      " |  \n",
      " |  set_ls(self, ls)\n",
      " |      Alias for `set_linestyle`.\n",
      " |  \n",
      " |  set_lw(self, w)\n",
      " |      Alias for `set_linewidth`.\n",
      " |  \n",
      " |  update_from(self, other)\n",
      " |      Updates this :class:`Patch` from the properties of *other*.\n",
      " |  \n",
      " |  ----------------------------------------------------------------------\n",
      " |  Data descriptors inherited from Patch:\n",
      " |  \n",
      " |  fill\n",
      " |      return whether fill is set\n",
      " |  \n",
      " |  ----------------------------------------------------------------------\n",
      " |  Data and other attributes inherited from Patch:\n",
      " |  \n",
      " |  validCap = ('butt', 'round', 'projecting')\n",
      " |  \n",
      " |  validJoin = ('miter', 'round', 'bevel')\n",
      " |  \n",
      " |  zorder = 1\n",
      " |  \n",
      " |  ----------------------------------------------------------------------\n",
      " |  Methods inherited from matplotlib.artist.Artist:\n",
      " |  \n",
      " |  __getstate__(self)\n",
      " |  \n",
      " |  add_callback(self, func)\n",
      " |      Add a callback function that will be called whenever one of the\n",
      " |      `.Artist`'s properties changes.\n",
      " |      \n",
      " |      Parameters\n",
      " |      ----------\n",
      " |      func : callable\n",
      " |          The callback function. It must have the signature::\n",
      " |      \n",
      " |              def func(artist: Artist) -> Any\n",
      " |      \n",
      " |          where *artist* is the calling `.Artist`. Return values may exist\n",
      " |          but are ignored.\n",
      " |      \n",
      " |      Returns\n",
      " |      -------\n",
      " |      oid : int\n",
      " |          The observer id associated with the callback. This id can be\n",
      " |          used for removing the callback with `.remove_callback` later.\n",
      " |      \n",
      " |      See Also\n",
      " |      --------\n",
      " |      remove_callback\n",
      " |  \n",
      " |  convert_xunits(self, x)\n",
      " |      Convert *x* using the unit type of the xaxis.\n",
      " |      \n",
      " |      If the artist is not in contained in an Axes or if the xaxis does not\n",
      " |      have units, *x* itself is returned.\n",
      " |  \n",
      " |  convert_yunits(self, y)\n",
      " |      Convert *y* using the unit type of the yaxis.\n",
      " |      \n",
      " |      If the artist is not in contained in an Axes or if the yaxis does not\n",
      " |      have units, *y* itself is returned.\n",
      " |  \n",
      " |  findobj(self, match=None, include_self=True)\n",
      " |      Find artist objects.\n",
      " |      \n",
      " |      Recursively find all `.Artist` instances contained in the artist.\n",
      " |      \n",
      " |      Parameters\n",
      " |      ----------\n",
      " |      match\n",
      " |          A filter criterion for the matches. This can be\n",
      " |      \n",
      " |          - *None*: Return all objects contained in artist.\n",
      " |          - A function with signature ``def match(artist: Artist) -> bool``.\n",
      " |            The result will only contain artists for which the function\n",
      " |            returns *True*.\n",
      " |          - A class instance: e.g., `.Line2D`. The result will only contain\n",
      " |            artists of this class or its subclasses (``isinstance`` check).\n",
      " |      \n",
      " |      include_self : bool\n",
      " |          Include *self* in the list to be checked for a match.\n",
      " |      \n",
      " |      Returns\n",
      " |      -------\n",
      " |      artists : list of `.Artist`\n",
      " |  \n",
      " |  format_cursor_data(self, data)\n",
      " |      Return a string representation of *data*.\n",
      " |      \n",
      " |      .. note::\n",
      " |          This method is intended to be overridden by artist subclasses.\n",
      " |          As an end-user of Matplotlib you will most likely not call this\n",
      " |          method yourself.\n",
      " |      \n",
      " |      The default implementation converts ints and floats and arrays of ints\n",
      " |      and floats into a comma-separated string enclosed in square brackets.\n",
      " |      \n",
      " |      See Also\n",
      " |      --------\n",
      " |      get_cursor_data\n",
      " |  \n",
      " |  get_agg_filter(self)\n",
      " |      Return filter function to be used for agg filter.\n",
      " |  \n",
      " |  get_alpha(self)\n",
      " |      Return the alpha value used for blending - not supported on all\n",
      " |      backends\n",
      " |  \n",
      " |  get_animated(self)\n",
      " |      Return the animated state.\n",
      " |  \n",
      " |  get_children(self)\n",
      " |      Return a list of the child `.Artist`\\s of this `.Artist`.\n",
      " |  \n",
      " |  get_clip_box(self)\n",
      " |      Return the clipbox.\n",
      " |  \n",
      " |  get_clip_on(self)\n",
      " |      Return whether the artist uses clipping.\n",
      " |  \n",
      " |  get_clip_path(self)\n",
      " |      Return the clip path.\n",
      " |  \n",
      " |  get_contains(self)\n",
      " |      Return the custom contains function of the artist if set, or *None*.\n",
      " |      \n",
      " |      See Also\n",
      " |      --------\n",
      " |      set_contains\n",
      " |  \n",
      " |  get_cursor_data(self, event)\n",
      " |      Return the cursor data for a given event.\n",
      " |      \n",
      " |      .. note::\n",
      " |          This method is intended to be overridden by artist subclasses.\n",
      " |          As an end-user of Matplotlib you will most likely not call this\n",
      " |          method yourself.\n",
      " |      \n",
      " |      Cursor data can be used by Artists to provide additional context\n",
      " |      information for a given event. The default implementation just returns\n",
      " |      *None*.\n",
      " |      \n",
      " |      Subclasses can override the method and return arbitrary data. However,\n",
      " |      when doing so, they must ensure that `.format_cursor_data` can convert\n",
      " |      the data to a string representation.\n",
      " |      \n",
      " |      The only current use case is displaying the z-value of an `.AxesImage`\n",
      " |      in the status bar of a plot window, while moving the mouse.\n",
      " |      \n",
      " |      Parameters\n",
      " |      ----------\n",
      " |      event : `matplotlib.backend_bases.MouseEvent`\n",
      " |      \n",
      " |      See Also\n",
      " |      --------\n",
      " |      format_cursor_data\n",
      " |  \n",
      " |  get_figure(self)\n",
      " |      Return the `.Figure` instance the artist belongs to.\n",
      " |  \n",
      " |  get_gid(self)\n",
      " |      Return the group id.\n",
      " |  \n",
      " |  get_in_layout(self)\n",
      " |      Return boolean flag, ``True`` if artist is included in layout\n",
      " |      calculations.\n",
      " |      \n",
      " |      E.g. :doc:`/tutorials/intermediate/constrainedlayout_guide`,\n",
      " |      `.Figure.tight_layout()`, and\n",
      " |      ``fig.savefig(fname, bbox_inches='tight')``.\n",
      " |  \n",
      " |  get_label(self)\n",
      " |      Return the label used for this artist in the legend.\n",
      " |  \n",
      " |  get_path_effects(self)\n",
      " |  \n",
      " |  get_picker(self)\n",
      " |      Return the picking behavior of the artist.\n",
      " |      \n",
      " |      The possible values are described in `.set_picker`.\n",
      " |      \n",
      " |      See Also\n",
      " |      --------\n",
      " |      set_picker, pickable, pick\n",
      " |  \n",
      " |  get_rasterized(self)\n",
      " |      Return whether the artist is to be rasterized.\n",
      " |  \n",
      " |  get_sketch_params(self)\n",
      " |      Returns the sketch parameters for the artist.\n",
      " |      \n",
      " |      Returns\n",
      " |      -------\n",
      " |      sketch_params : tuple or None\n",
      " |      \n",
      " |          A 3-tuple with the following elements:\n",
      " |      \n",
      " |          - *scale*: The amplitude of the wiggle perpendicular to the\n",
      " |            source line.\n",
      " |          - *length*: The length of the wiggle along the line.\n",
      " |          - *randomness*: The scale factor by which the length is\n",
      " |            shrunken or expanded.\n",
      " |      \n",
      " |          Returns *None* if no sketch parameters were set.\n",
      " |  \n",
      " |  get_snap(self)\n",
      " |      Returns the snap setting.\n",
      " |      \n",
      " |      See `.set_snap` for details.\n",
      " |  \n",
      " |  get_tightbbox(self, renderer)\n",
      " |      Like `Artist.get_window_extent`, but includes any clipping.\n",
      " |      \n",
      " |      Parameters\n",
      " |      ----------\n",
      " |      renderer : `.RendererBase` instance\n",
      " |          renderer that will be used to draw the figures (i.e.\n",
      " |          ``fig.canvas.get_renderer()``)\n",
      " |      \n",
      " |      Returns\n",
      " |      -------\n",
      " |      bbox : `.BBox`\n",
      " |          The enclosing bounding box (in figure pixel co-ordinates).\n",
      " |  \n",
      " |  get_transformed_clip_path_and_affine(self)\n",
      " |      Return the clip path with the non-affine part of its\n",
      " |      transformation applied, and the remaining affine part of its\n",
      " |      transformation.\n",
      " |  \n",
      " |  get_url(self)\n",
      " |      Return the url.\n",
      " |  \n",
      " |  get_visible(self)\n",
      " |      Return the visibility.\n",
      " |  \n",
      " |  get_zorder(self)\n",
      " |      Return the artist's zorder.\n",
      " |  \n",
      " |  have_units(self)\n",
      " |      Return *True* if units are set on the *x* or *y* axes.\n",
      " |  \n",
      " |  is_transform_set(self)\n",
      " |      Return whether the Artist has an explicitly set transform.\n",
      " |      \n",
      " |      This is *True* after `.set_transform` has been called.\n",
      " |  \n",
      " |  pchanged(self)\n",
      " |      Call all of the registered callbacks.\n",
      " |      \n",
      " |      This function is triggered internally when a property is changed.\n",
      " |      \n",
      " |      See Also\n",
      " |      --------\n",
      " |      add_callback\n",
      " |      remove_callback\n",
      " |  \n",
      " |  pick(self, mouseevent)\n",
      " |      Process a pick event.\n",
      " |      \n",
      " |      Each child artist will fire a pick event if *mouseevent* is over\n",
      " |      the artist and the artist has picker set.\n",
      " |      \n",
      " |      See Also\n",
      " |      --------\n",
      " |      set_picker, get_picker, pickable\n",
      " |  \n",
      " |  pickable(self)\n",
      " |      Return whether the artist is pickable.\n",
      " |      \n",
      " |      See Also\n",
      " |      --------\n",
      " |      set_picker, get_picker, pick\n",
      " |  \n",
      " |  properties(self)\n",
      " |      Return a dictionary of all the properties of the artist.\n",
      " |  \n",
      " |  remove(self)\n",
      " |      Remove the artist from the figure if possible.\n",
      " |      \n",
      " |      The effect will not be visible until the figure is redrawn, e.g.,\n",
      " |      with `.FigureCanvasBase.draw_idle`.  Call `~.axes.Axes.relim` to\n",
      " |      update the axes limits if desired.\n",
      " |      \n",
      " |      Note: `~.axes.Axes.relim` will not see collections even if the\n",
      " |      collection was added to the axes with *autolim* = True.\n",
      " |      \n",
      " |      Note: there is no support for removing the artist's legend entry.\n",
      " |  \n",
      " |  remove_callback(self, oid)\n",
      " |      Remove a callback based on its observer id.\n",
      " |      \n",
      " |      See Also\n",
      " |      --------\n",
      " |      add_callback\n",
      " |  \n",
      " |  set(self, **kwargs)\n",
      " |      A property batch setter.  Pass *kwargs* to set properties.\n",
      " |  \n",
      " |  set_agg_filter(self, filter_func)\n",
      " |      Set the agg filter.\n",
      " |      \n",
      " |      Parameters\n",
      " |      ----------\n",
      " |      filter_func : callable\n",
      " |          A filter function, which takes a (m, n, 3) float array and a dpi\n",
      " |          value, and returns a (m, n, 3) array.\n",
      " |      \n",
      " |          .. ACCEPTS: a filter function, which takes a (m, n, 3) float array\n",
      " |              and a dpi value, and returns a (m, n, 3) array\n",
      " |  \n",
      " |  set_animated(self, b)\n",
      " |      Set the artist's animation state.\n",
      " |      \n",
      " |      Parameters\n",
      " |      ----------\n",
      " |      b : bool\n",
      " |  \n",
      " |  set_clip_box(self, clipbox)\n",
      " |      Set the artist's clip `.Bbox`.\n",
      " |      \n",
      " |      Parameters\n",
      " |      ----------\n",
      " |      clipbox : `.Bbox`\n",
      " |  \n",
      " |  set_clip_on(self, b)\n",
      " |      Set whether the artist uses clipping.\n",
      " |      \n",
      " |      When False artists will be visible out side of the axes which\n",
      " |      can lead to unexpected results.\n",
      " |      \n",
      " |      Parameters\n",
      " |      ----------\n",
      " |      b : bool\n",
      " |  \n",
      " |  set_clip_path(self, path, transform=None)\n",
      " |      Set the artist's clip path, which may be:\n",
      " |      \n",
      " |      - a :class:`~matplotlib.patches.Patch` (or subclass) instance; or\n",
      " |      - a :class:`~matplotlib.path.Path` instance, in which case a\n",
      " |        :class:`~matplotlib.transforms.Transform` instance, which will be\n",
      " |        applied to the path before using it for clipping, must be provided;\n",
      " |        or\n",
      " |      - ``None``, to remove a previously set clipping path.\n",
      " |      \n",
      " |      For efficiency, if the path happens to be an axis-aligned rectangle,\n",
      " |      this method will set the clipping box to the corresponding rectangle\n",
      " |      and set the clipping path to ``None``.\n",
      " |      \n",
      " |      ACCEPTS: [(`~matplotlib.path.Path`, `.Transform`) | `.Patch` | None]\n",
      " |  \n",
      " |  set_contains(self, picker)\n",
      " |      Define a custom contains test for the artist.\n",
      " |      \n",
      " |      The provided callable replaces the default `.contains` method\n",
      " |      of the artist.\n",
      " |      \n",
      " |      Parameters\n",
      " |      ----------\n",
      " |      picker : callable\n",
      " |          A custom picker function to evaluate if an event is within the\n",
      " |          artist. The function must have the signature::\n",
      " |      \n",
      " |              def contains(artist: Artist, event: MouseEvent) -> bool, dict\n",
      " |      \n",
      " |          that returns:\n",
      " |      \n",
      " |          - a bool indicating if the event is within the artist\n",
      " |          - a dict of additional information. The dict should at least\n",
      " |            return the same information as the default ``contains()``\n",
      " |            implementation of the respective artist, but may provide\n",
      " |            additional information.\n",
      " |  \n",
      " |  set_figure(self, fig)\n",
      " |      Set the `.Figure` instance the artist belongs to.\n",
      " |      \n",
      " |      Parameters\n",
      " |      ----------\n",
      " |      fig : `.Figure`\n",
      " |  \n",
      " |  set_gid(self, gid)\n",
      " |      Set the (group) id for the artist.\n",
      " |      \n",
      " |      Parameters\n",
      " |      ----------\n",
      " |      gid : str\n",
      " |  \n",
      " |  set_in_layout(self, in_layout)\n",
      " |      Set if artist is to be included in layout calculations,\n",
      " |      E.g. :doc:`/tutorials/intermediate/constrainedlayout_guide`,\n",
      " |      `.Figure.tight_layout()`, and\n",
      " |      ``fig.savefig(fname, bbox_inches='tight')``.\n",
      " |      \n",
      " |      Parameters\n",
      " |      ----------\n",
      " |      in_layout : bool\n",
      " |  \n",
      " |  set_label(self, s)\n",
      " |      Set a label that will be displayed in the legend.\n",
      " |      \n",
      " |      Parameters\n",
      " |      ----------\n",
      " |      s : object\n",
      " |          *s* will be converted to a string by calling `str`.\n",
      " |  \n",
      " |  set_path_effects(self, path_effects)\n",
      " |      Set the path effects.\n",
      " |      \n",
      " |      Parameters\n",
      " |      ----------\n",
      " |      path_effects : `.AbstractPathEffect`\n",
      " |  \n",
      " |  set_picker(self, picker)\n",
      " |      Define the picking behavior of the artist.\n",
      " |      \n",
      " |      Parameters\n",
      " |      ----------\n",
      " |      picker : None or bool or float or callable\n",
      " |          This can be one of the following:\n",
      " |      \n",
      " |          - *None*: Picking is disabled for this artist (default).\n",
      " |      \n",
      " |          - A boolean: If *True* then picking will be enabled and the\n",
      " |            artist will fire a pick event if the mouse event is over\n",
      " |            the artist.\n",
      " |      \n",
      " |          - A float: If picker is a number it is interpreted as an\n",
      " |            epsilon tolerance in points and the artist will fire\n",
      " |            off an event if it's data is within epsilon of the mouse\n",
      " |            event.  For some artists like lines and patch collections,\n",
      " |            the artist may provide additional data to the pick event\n",
      " |            that is generated, e.g., the indices of the data within\n",
      " |            epsilon of the pick event\n",
      " |      \n",
      " |          - A function: If picker is callable, it is a user supplied\n",
      " |            function which determines whether the artist is hit by the\n",
      " |            mouse event::\n",
      " |      \n",
      " |              hit, props = picker(artist, mouseevent)\n",
      " |      \n",
      " |            to determine the hit test.  if the mouse event is over the\n",
      " |            artist, return *hit=True* and props is a dictionary of\n",
      " |            properties you want added to the PickEvent attributes.\n",
      " |  \n",
      " |  set_rasterized(self, rasterized)\n",
      " |      Force rasterized (bitmap) drawing in vector backend output.\n",
      " |      \n",
      " |      Defaults to None, which implies the backend's default behavior.\n",
      " |      \n",
      " |      Parameters\n",
      " |      ----------\n",
      " |      rasterized : bool or None\n",
      " |  \n",
      " |  set_sketch_params(self, scale=None, length=None, randomness=None)\n",
      " |      Sets the sketch parameters.\n",
      " |      \n",
      " |      Parameters\n",
      " |      ----------\n",
      " |      \n",
      " |      scale : float, optional\n",
      " |          The amplitude of the wiggle perpendicular to the source\n",
      " |          line, in pixels.  If scale is `None`, or not provided, no\n",
      " |          sketch filter will be provided.\n",
      " |      \n",
      " |      length : float, optional\n",
      " |           The length of the wiggle along the line, in pixels\n",
      " |           (default 128.0)\n",
      " |      \n",
      " |      randomness : float, optional\n",
      " |          The scale factor by which the length is shrunken or\n",
      " |          expanded (default 16.0)\n",
      " |      \n",
      " |          .. ACCEPTS: (scale: float, length: float, randomness: float)\n",
      " |  \n",
      " |  set_snap(self, snap)\n",
      " |      Set the snapping behavior.\n",
      " |      \n",
      " |      Snapping aligns positions with the pixel grid, which results in\n",
      " |      clearer images. For example, if a black line of 1px width was\n",
      " |      defined at a position in between two pixels, the resulting image\n",
      " |      would contain the interpolated value of that line in the pixel grid,\n",
      " |      which would be a grey value on both adjacent pixel positions. In\n",
      " |      contrast, snapping will move the line to the nearest integer pixel\n",
      " |      value, so that the resulting image will really contain a 1px wide\n",
      " |      black line.\n",
      " |      \n",
      " |      Snapping is currently only supported by the Agg and MacOSX backends.\n",
      " |      \n",
      " |      Parameters\n",
      " |      ----------\n",
      " |      snap : bool or None\n",
      " |          Possible values:\n",
      " |      \n",
      " |          - *True*: Snap vertices to the nearest pixel center.\n",
      " |          - *False*: Do not modify vertex positions.\n",
      " |          - *None*: (auto) If the path contains only rectilinear line\n",
      " |            segments, round to the nearest pixel center.\n",
      " |  \n",
      " |  set_transform(self, t)\n",
      " |      Set the artist transform.\n",
      " |      \n",
      " |      Parameters\n",
      " |      ----------\n",
      " |      t : `.Transform`\n",
      " |  \n",
      " |  set_url(self, url)\n",
      " |      Set the url for the artist.\n",
      " |      \n",
      " |      Parameters\n",
      " |      ----------\n",
      " |      url : str\n",
      " |  \n",
      " |  set_visible(self, b)\n",
      " |      Set the artist's visibility.\n",
      " |      \n",
      " |      Parameters\n",
      " |      ----------\n",
      " |      b : bool\n",
      " |  \n",
      " |  set_zorder(self, level)\n",
      " |      Set the zorder for the artist.  Artists with lower zorder\n",
      " |      values are drawn first.\n",
      " |      \n",
      " |      Parameters\n",
      " |      ----------\n",
      " |      level : float\n",
      " |  \n",
      " |  update(self, props)\n",
      " |      Update this artist's properties from the dictionary *props*.\n",
      " |  \n",
      " |  ----------------------------------------------------------------------\n",
      " |  Data descriptors inherited from matplotlib.artist.Artist:\n",
      " |  \n",
      " |  __dict__\n",
      " |      dictionary for instance variables (if defined)\n",
      " |  \n",
      " |  __weakref__\n",
      " |      list of weak references to the object (if defined)\n",
      " |  \n",
      " |  aname\n",
      " |  \n",
      " |  axes\n",
      " |      The `~.axes.Axes` instance the artist resides in, or *None*.\n",
      " |  \n",
      " |  mouseover\n",
      " |  \n",
      " |  stale\n",
      " |      Whether the artist is 'stale' and needs to be re-drawn for the output\n",
      " |      to match the internal state of the artist.\n",
      " |  \n",
      " |  sticky_edges\n",
      " |      ``x`` and ``y`` sticky edge lists for autoscaling.\n",
      " |      \n",
      " |      When performing autoscaling, if a data limit coincides with a value in\n",
      " |      the corresponding sticky_edges list, then no margin will be added--the\n",
      " |      view limit \"sticks\" to the edge. A typical use case is histograms,\n",
      " |      where one usually expects no margin on the bottom edge (0) of the\n",
      " |      histogram.\n",
      " |      \n",
      " |      This attribute cannot be assigned to; however, the ``x`` and ``y``\n",
      " |      lists can be modified in place as needed.\n",
      " |      \n",
      " |      Examples\n",
      " |      --------\n",
      " |      \n",
      " |      >>> artist.sticky_edges.x[:] = (xmin, xmax)\n",
      " |      >>> artist.sticky_edges.y[:] = (ymin, ymax)\n",
      "\n"
     ]
    }
   ],
   "source": [
    "help(pat.Rectangle)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "[\n",
    "    {\"text\": \"America 1800~1820\", \"focusArgs\": [[1800, 1820], [\"United States\"]]},\n",
    "    {\"text\": \" no focus \", \"focusArgs\": null},\n",
    "    {\"text\": \" 1900~2000 \", \"focusArgs\": [[1900, 2000], null]},\n",
    "    {\"text\": \" Japan \", \"focusArgs\": [null, [\"Japan\"]]},\n",
    "    {\"text\": \"Japan 1990~2000\", \"focusArgs\": [[1990, 2000], [\"Japan\"]]}\n",
    "]\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 87,
   "metadata": {},
   "outputs": [],
   "source": [
    "str.format?"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 90,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'1joge'"
      ]
     },
     "execution_count": 90,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "'{country}joge'.format(country=1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 79,
   "metadata": {},
   "outputs": [],
   "source": [
    "template = \"{country}'s {ind} has {ptype} ({from_} ~ {to_})\\n\"\n",
    "template_A = \"{country}'s {ind} has peak from {from_} to {to_}\\n\"\n",
    "template_B = \"{country}'s {ind}'s tread has changed from {from_} to {to_}\\n\""
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 84,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "ef38b879de3d48468d1a41176588bc25",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(HTML(value=''), FloatProgress(value=0.0, max=180.0), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/Users/hirotanaka/.pyenv/versions/miniconda3-4.3.30/envs/tdb/lib/python3.7/site-packages/ipykernel_launcher.py:45: FutureWarning: `rcond` parameter will change to the default of machine precision times ``max(M, N)`` where M and N are the input matrix dimensions.\n",
      "To use the future default and silence this warning we advise to pass `rcond=None`, to keep using the old, explicitly pass `rcond=-1`.\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n"
     ]
    },
    {
     "ename": "IndexError",
     "evalue": "list index out of range",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mIndexError\u001b[0m                                Traceback (most recent call last)",
      "\u001b[0;32m<ipython-input-84-ea1189df121b>\u001b[0m in \u001b[0;36m<module>\u001b[0;34m\u001b[0m\n\u001b[1;32m     11\u001b[0m     \u001b[0;32mfor\u001b[0m \u001b[0mind\u001b[0m \u001b[0;32min\u001b[0m \u001b[0;34m'income population lifeExpectancy'\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0msplit\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     12\u001b[0m         \u001b[0mys\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mdf\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0mind\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 13\u001b[0;31m         \u001b[0;32mfor\u001b[0m \u001b[0mfrom_\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mto_\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mptype\u001b[0m \u001b[0;32min\u001b[0m \u001b[0mA\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mys\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mwindow_size_A\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m     14\u001b[0m             \u001b[0mfrom_\u001b[0m \u001b[0;34m+=\u001b[0m \u001b[0;36m1800\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     15\u001b[0m             \u001b[0mto_\u001b[0m \u001b[0;34m+=\u001b[0m \u001b[0;36m1800\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m<ipython-input-82-b2a5574f75af>\u001b[0m in \u001b[0;36mA\u001b[0;34m(ys, window_size, K)\u001b[0m\n\u001b[1;32m     20\u001b[0m     \u001b[0mpeaks\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0msorted\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mpeaks\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mkey\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mlambda\u001b[0m \u001b[0mx\u001b[0m\u001b[0;34m:\u001b[0m \u001b[0mx\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;36m0\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     21\u001b[0m     \u001b[0mret\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;34m[\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 22\u001b[0;31m     \u001b[0mpre_from_\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mpre_to_\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mp_type_pre\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mv\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mpeaks\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;36m0\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m     23\u001b[0m     \u001b[0;32mif\u001b[0m \u001b[0mv\u001b[0m \u001b[0;34m==\u001b[0m \u001b[0;36m0\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     24\u001b[0m         \u001b[0;32mreturn\u001b[0m \u001b[0mret\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;31mIndexError\u001b[0m: list index out of range"
     ]
    }
   ],
   "source": [
    "window_size_A = 6\n",
    "window_size_B = 4\n",
    "window_size_C = 4\n",
    "\n",
    "g = new_nations.groupby('name')\n",
    "data = []\n",
    "for country in tqdm(g.groups.keys()):\n",
    "    df = g.get_group(country).sort_values('year').set_index('year').interpolate('time')\n",
    "    data.append({'text': country,\n",
    "                'focusArgs': [None, [country]]})\n",
    "    for ind in 'income population lifeExpectancy'.split():\n",
    "        ys = df[ind]\n",
    "        for from_, to_, ptype in A(ys, window_size_A):\n",
    "            from_ += 1800\n",
    "            to_ += 1800\n",
    "            d_ = {'text': template.format(country=country, ind=ind, from_=from_, to_=to_, ptype=ptype),\n",
    "                'focusArgs': [[from_, to_], [country]]}\n",
    "            data.append(d_)\n",
    "        for from_, to_, ptype in B(ys, window_size_B):\n",
    "            from_ += 1800\n",
    "            to_ += 1800\n",
    "            d_ = {'text': template.format(country=country, ind=ind, from_=from_, to_=to_, ptype=ptype),\n",
    "                'focusArgs': [[from_, to_], [country]]}\n",
    "            data.append(d_)\n",
    "        for from_, to_, ptype in large_grad(ys, window_size_C):\n",
    "            from_ += 1800\n",
    "            to_ += 1800\n",
    "            d_ = {'text': template.format(country=country, ind=ind, from_=from_, to_=to_, ptype=ptype),\n",
    "                'focusArgs': [[from_, to_], [country]]}\n",
    "            data.append(d_)\n",
    "\"\"\"\n",
    "with open('../public/afghan.json', 'w') as  f:\n",
    "    json_text = json.dumps(data)\n",
    "    f.write(json_text)\n",
    "\"\"\"\n",
    "len(data)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": 108,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "['BACKSLASH',\n",
       " 'FLAGS',\n",
       " 'JSONArray',\n",
       " 'JSONDecodeError',\n",
       " 'JSONDecoder',\n",
       " 'JSONObject',\n",
       " 'NaN',\n",
       " 'NegInf',\n",
       " 'PosInf',\n",
       " 'STRINGCHUNK',\n",
       " 'WHITESPACE',\n",
       " 'WHITESPACE_STR',\n",
       " '_CONSTANTS',\n",
       " '__all__',\n",
       " '__builtins__',\n",
       " '__cached__',\n",
       " '__doc__',\n",
       " '__file__',\n",
       " '__loader__',\n",
       " '__name__',\n",
       " '__package__',\n",
       " '__spec__',\n",
       " '_decode_uXXXX',\n",
       " 'c_scanstring',\n",
       " 'py_scanstring',\n",
       " 're',\n",
       " 'scanner',\n",
       " 'scanstring']"
      ]
     },
     "execution_count": 108,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "dir(json.decoder)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 116,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[{'text': \"Afghanistan's income has peak from 181 to 185\",\n",
       "  'focus_args': [[181, 185], ['Afghanistan']]},\n",
       " {'text': \"Afghanistan's income has peak from 175 to 179\",\n",
       "  'focus_args': [[175, 179], ['Afghanistan']]},\n",
       " {'text': \"Afghanistan's income has peak from 197 to 201\",\n",
       "  'focus_args': [[197, 201], ['Afghanistan']]},\n",
       " {'text': \"Afghanistan's income has peak from 164 to 168\",\n",
       "  'focus_args': [[164, 168], ['Afghanistan']]},\n",
       " {'text': \"Afghanistan's income has peak from 154 to 158\",\n",
       "  'focus_args': [[154, 158], ['Afghanistan']]},\n",
       " {'text': \"Afghanistan's income's tread has changed from 178 to 183\",\n",
       "  'focus_args': [[178, 183], ['Afghanistan']]},\n",
       " {'text': \"Afghanistan's income's tread has changed from 180 to 185\",\n",
       "  'focus_args': [[180, 185], ['Afghanistan']]},\n",
       " {'text': \"Afghanistan's income's tread has changed from 181 to 186\",\n",
       "  'focus_args': [[181, 186], ['Afghanistan']]},\n",
       " {'text': \"Afghanistan's income's tread has changed from 183 to 188\",\n",
       "  'focus_args': [[183, 188], ['Afghanistan']]},\n",
       " {'text': \"Afghanistan's income's tread has changed from 184 to 189\",\n",
       "  'focus_args': [[184, 189], ['Afghanistan']]},\n",
       " {'text': \"Afghanistan's income's tread has changed from 186 to 191\",\n",
       "  'focus_args': [[186, 191], ['Afghanistan']]},\n",
       " {'text': \"Afghanistan's income's tread has changed from 191 to 196\",\n",
       "  'focus_args': [[191, 196], ['Afghanistan']]},\n",
       " {'text': \"Afghanistan's income's tread has changed from 192 to 197\",\n",
       "  'focus_args': [[192, 197], ['Afghanistan']]},\n",
       " {'text': \"Afghanistan's income's tread has changed from 199 to 204\",\n",
       "  'focus_args': [[199, 204], ['Afghanistan']]},\n",
       " {'text': \"Afghanistan's income's tread has changed from 205 to 210\",\n",
       "  'focus_args': [[205, 210], ['Afghanistan']]},\n",
       " {'text': \"Afghanistan's population has peak from 180 to 184\",\n",
       "  'focus_args': [[180, 184], ['Afghanistan']]},\n",
       " {'text': \"Afghanistan's population has peak from 207 to 210\",\n",
       "  'focus_args': [[207, 210], ['Afghanistan']]},\n",
       " {'text': \"Afghanistan's population has peak from 73 to 77\",\n",
       "  'focus_args': [[73, 77], ['Afghanistan']]},\n",
       " {'text': \"Afghanistan's population has peak from 72 to 76\",\n",
       "  'focus_args': [[72, 76], ['Afghanistan']]},\n",
       " {'text': \"Afghanistan's population has peak from 71 to 75\",\n",
       "  'focus_args': [[71, 75], ['Afghanistan']]},\n",
       " {'text': \"Afghanistan's population's tread has changed from 177 to 182\",\n",
       "  'focus_args': [[177, 182], ['Afghanistan']]},\n",
       " {'text': \"Afghanistan's population's tread has changed from 178 to 183\",\n",
       "  'focus_args': [[178, 183], ['Afghanistan']]},\n",
       " {'text': \"Afghanistan's population's tread has changed from 180 to 185\",\n",
       "  'focus_args': [[180, 185], ['Afghanistan']]},\n",
       " {'text': \"Afghanistan's population's tread has changed from 181 to 186\",\n",
       "  'focus_args': [[181, 186], ['Afghanistan']]},\n",
       " {'text': \"Afghanistan's population's tread has changed from 189 to 194\",\n",
       "  'focus_args': [[189, 194], ['Afghanistan']]},\n",
       " {'text': \"Afghanistan's population's tread has changed from 190 to 195\",\n",
       "  'focus_args': [[190, 195], ['Afghanistan']]},\n",
       " {'text': \"Afghanistan's population's tread has changed from 192 to 197\",\n",
       "  'focus_args': [[192, 197], ['Afghanistan']]},\n",
       " {'text': \"Afghanistan's population's tread has changed from 199 to 204\",\n",
       "  'focus_args': [[199, 204], ['Afghanistan']]},\n",
       " {'text': \"Afghanistan's population's tread has changed from 200 to 205\",\n",
       "  'focus_args': [[200, 205], ['Afghanistan']]},\n",
       " {'text': \"Afghanistan's lifeExpectancy has peak from 194 to 198\",\n",
       "  'focus_args': [[194, 198], ['Afghanistan']]},\n",
       " {'text': \"Afghanistan's lifeExpectancy has peak from 62 to 66\",\n",
       "  'focus_args': [[62, 66], ['Afghanistan']]},\n",
       " {'text': \"Afghanistan's lifeExpectancy has peak from 73 to 77\",\n",
       "  'focus_args': [[73, 77], ['Afghanistan']]},\n",
       " {'text': \"Afghanistan's lifeExpectancy has peak from 72 to 76\",\n",
       "  'focus_args': [[72, 76], ['Afghanistan']]},\n",
       " {'text': \"Afghanistan's lifeExpectancy has peak from 71 to 75\",\n",
       "  'focus_args': [[71, 75], ['Afghanistan']]},\n",
       " {'text': \"Afghanistan's lifeExpectancy's tread has changed from 148 to 153\",\n",
       "  'focus_args': [[148, 153], ['Afghanistan']]},\n",
       " {'text': \"Afghanistan's lifeExpectancy's tread has changed from 149 to 154\",\n",
       "  'focus_args': [[149, 154], ['Afghanistan']]},\n",
       " {'text': \"Afghanistan's lifeExpectancy's tread has changed from 199 to 204\",\n",
       "  'focus_args': [[199, 204], ['Afghanistan']]},\n",
       " {'text': \"Afghanistan's lifeExpectancy's tread has changed from 200 to 205\",\n",
       "  'focus_args': [[200, 205], ['Afghanistan']]},\n",
       " {'text': \"Afghanistan's lifeExpectancy's tread has changed from 201 to 206\",\n",
       "  'focus_args': [[201, 206], ['Afghanistan']]}]"
      ]
     },
     "execution_count": 116,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "with open('../public/afghan.json') as  f:\n",
    "    tmp = json.load(f)\n",
    "tmp"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 62,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "209 210\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/Users/hirotanaka/.pyenv/versions/miniconda3-4.3.30/envs/tdb/lib/python3.7/site-packages/ipykernel_launcher.py:26: FutureWarning: `rcond` parameter will change to the default of machine precision times ``max(M, N)`` where M and N are the input matrix dimensions.\n",
      "To use the future default and silence this warning we advise to pass `rcond=None`, to keep using the old, explicitly pass `rcond=-1`.\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "10"
      ]
     },
     "execution_count": 62,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "len(B(ys, 5))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 40,
   "metadata": {},
   "outputs": [
    {
     "ename": "AttributeError",
     "evalue": "module 'matplotlib.pyplot' has no attribute 'rect'",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mAttributeError\u001b[0m                            Traceback (most recent call last)",
      "\u001b[0;32m<ipython-input-40-af4237d73a86>\u001b[0m in \u001b[0;36m<module>\u001b[0;34m\u001b[0m\n\u001b[0;32m----> 1\u001b[0;31m \u001b[0mplt\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mrect\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m",
      "\u001b[0;31mAttributeError\u001b[0m: module 'matplotlib.pyplot' has no attribute 'rect'"
     ]
    }
   ],
   "source": [
    "plt.rect"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/Users/hirotanaka/.pyenv/versions/miniconda3-4.3.30/envs/tdb/lib/python3.7/site-packages/ipykernel_launcher.py:35: FutureWarning: `rcond` parameter will change to the default of machine precision times ``max(M, N)`` where M and N are the input matrix dimensions.\n",
      "To use the future default and silence this warning we advise to pass `rcond=None`, to keep using the old, explicitly pass `rcond=-1`.\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "210"
      ]
     },
     "execution_count": 20,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "len(grads(df['income'], 5))"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.6"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
